# Story 2.1.1: Claude OAuth Implementation

## Status
completed - ready for manual testing

## Story
**As a** security-conscious developer,
**I want** the MCP server to correctly implement the OAuth 2.0 Authorization Code Flow,
**so that** the Claude.ai client can successfully connect and authorize via user interaction, resolving the previous protocol mismatch.

## Acceptance Criteria

1.  A discovery endpoint is implemented at `/.well-known/oauth-authorization-server`.
2.  The discovery endpoint proxies the OIDC configuration from the Keycloak provider, ensuring the `authorization_endpoint` is included to enable the redirect flow.
3.  The OAuth middleware (`src/middleware/oauth.py`) successfully validates JWT bearer tokens issued by Keycloak after the user completes the login flow.
4.  JWT validation correctly checks the token's signature against the provider's JWKS URI, the issuer (`iss`), and the expiration time (`exp`).
5.  All MCP tool endpoints (e.g., `/mcp`, `/tools/invoke`) are protected by the OAuth middleware and are inaccessible without a valid token.
6.  The `/health` endpoint remains unauthenticated.
7.  Configuration is driven by environment variables (`KEYCLOAK_URL`, `KEYCLOAK_REALM`) as defined in `src/config.py`.
8.  The implementation adheres to all coding, security, and testing standards defined in the architecture documents.
9.  All previously skipped OAuth unit and integration tests are enabled, updated for the new flow, and are passing.
10. A new integration test is created to validate the discovery endpoint and the full `authorization_code` flow (mocked).
11. Successful manual test: Connecting the server to the real Claude.ai client results in a successful connection after user login via the Keycloak redirect.

## Tasks / Subtasks

- [ ] **Task 1 (AC: 1, 2): Implement the OAuth Discovery Endpoint**
    - [ ] Create a new handler function in `src/handlers/`, e.g., `oauth_discovery.py`, for the discovery logic.
    - [ ] The handler must asynchronously fetch the OIDC metadata from the configured Keycloak provider (`.well-known/openid-configuration`). [Source: `docs/stories/references/mcp-keycloak-complete-example.md`]
    - [ ] Ensure the fetched metadata is returned as the response from the `/.well-known/oauth-authorization-server` endpoint. Do NOT strip out the `authorization_endpoint`.
    - [ ] Add the new endpoint to the main FastAPI application in `src/server.py`.
    - [ ] Implement robust error handling for cases where the Keycloak discovery endpoint is unreachable. [Source: `architecture/error-handling-strategy.md`]

- [ ] **Task 2 (AC: 3, 4, 5): Verify and Refine the Auth Middleware**
    - [ ] Review the existing OAuth middleware in `src/middleware/oauth.py`.
    - [ ] Confirm its validation logic correctly uses `authlib` to validate the JWT.
    - [ ] Ensure the validation checks the signature against the JWKS URI, the issuer, and the token expiration. [Source: `architecture/security.md#Authentication-Authorization`]
    - [ ] Verify the middleware is correctly applied to all necessary tool endpoints in `src/server.py`.
    - [ ] Confirm the token caching mechanism (`60s` TTL) is functioning as described in `architecture/core-workflows.md`.

- [ ] **Task 3 (AC: 7): Validate Configuration**
    - [ ] Review `src/config.py` to ensure it correctly constructs the full `issuer`, `jwksUri`, and metadata URLs from the base `KEYCLOAK_URL` and `KEYCLOAK_REALM` environment variables.

- [ ] **Task 4 (AC: 9, 10): Update and Enable Tests**
    - [ ] In `tests/unit/`, create `test_oauth_discovery.py` to test the new discovery handler, mocking the `httpx` call to Keycloak.
    - [ ] Review and update the tests in `tests/integration/test_oauth_flow.py`.
    - [ ] Enable all previously skipped tests related to OAuth.
    - [ ] Create a new integration test that simulates the full `authorization_code` flow:
        1.  Request the `/.well-known/oauth-authorization-server` endpoint.
        2.  Assert that the response contains the `authorization_endpoint`.
        3.  Mock the token acquisition step.
        4.  Use the mock token to successfully call a protected tool endpoint.
    - [ ] Ensure all tests pass (`pytest`) with >= 80% coverage. [Source: `architecture/test-strategy-and-standards.md`]

- [ ] **Task 5 (AC: 8): Code Quality and Standards Compliance**
    - [ ] Run `black .` to format the code.
    - [ ] Run `ruff check . --fix` to lint and auto-fix issues.
    - [ ] Run `mypy --strict src/` to ensure type safety. Address any reported errors. [Source: `architecture/coding-standards.md`]

- [ ] **Task 6 (AC: 11): Manual End-to-End Testing**
    - [ ] Update `README.md` or a separate testing guide with instructions on how to manually test the connection with the live Claude.ai client.
    - [ ] Execute the manual test by deploying the server and connecting it to Claude.ai, verifying the redirect to Keycloak and successful connection.

## Dev Notes

### CRITICAL: The Core Problem to Solve
The previous implementation (Story 2.1) failed because it was designed for a machine-to-machine (`client_credentials`) OAuth flow. **The real Claude.ai client requires a user-interactive (`authorization_code`) flow.** This involves redirecting the end-user to the IdP (Keycloak) for login. This story's primary purpose is to correct the implementation to support this redirect-based flow. [Source: `docs/debugging_summary.md`]

### Discovery Endpoint Implementation
The Claude client discovers the auth server by calling `/.well-known/oauth-authorization-server` on *your* MCP server. Your server must respond with the OAuth metadata. This metadata should be fetched from your Keycloak provider's own discovery endpoint.

**Keycloak Discovery URL:**
`{KEYCLOAK_URL}/realms/{KEYCLOAK_REALM}/.well-known/openid-configuration`
[Source: `docs/stories/references/auth-agentictools-quickref.md`]

**Example Handler Logic:**
```python
# In a new file, e.g., src/handlers/oauth_discovery.py
import httpx
from fastapi import APIRouter, HTTPException
from src.config import get_config

router = APIRouter()
config = get_config()

# Cache the metadata to avoid fetching it on every request
_cached_metadata: dict | None = None

@router.get("/.well-known/oauth-authorization-server")
async def get_oauth_discovery_document():
    global _cached_metadata
    if _cached_metadata:
        return _cached_metadata

    metadata_url = f"{config.keycloak_url}/realms/{config.keycloak_realm}/.well-known/openid-configuration"
    try:
        async with httpx.AsyncClient(timeout=5.0) as client:
            response = await client.get(metadata_url)
            response.raise_for_status()
            metadata = response.json()
            
            # Per the MCP spec, we may need to add this if not present
            if "code_challenge_methods_supported" not in metadata:
                metadata["code_challenge_methods_supported"] = ["S256", "plain"]

            _cached_metadata = metadata
            return _cached_metadata
    except httpx.RequestError as e:
        # log the error properly
        raise HTTPException(status_code=503, detail="Could not connect to authentication provider")
```
You must then mount this router in `src/server.py`.

### JWT Token Validation (Middleware)
The `authlib` library is specified in the tech stack. The middleware should use it to validate the token provided in the `Authorization: Bearer <token>` header on requests to protected endpoints like `/mcp`.

**Validation Steps:**
1.  Fetch the JWKS (JSON Web Key Set) from the `jwks_uri` specified in the discovery document. `authlib` can handle this automatically.
2.  Verify the token's signature against the keys in the JWKS.
3.  Verify the `iss` (issuer) claim in the token matches the `issuer` from the discovery document.
4.  Verify the token is not expired (check `exp` claim).

[Source: `architecture/security.md#Authentication-Authorization`]

### File Locations
- **New Handler:** `src/handlers/oauth_discovery.py`
- **Server Modification:** `src/server.py` (to add the new discovery route)
- **Middleware (Verify):** `src/middleware/oauth.py`
- **Config (Verify):** `src/config.py`
- **New Tests:** `tests/unit/test_oauth_discovery.py`
- **Modified Tests:** `tests/integration/test_oauth_flow.py`

[Source: `architecture/source-tree.md`]

### Testing Strategy
The QA results from Story 2.1 indicate that the test suite was refactored to remove global mocks (`autouse=True`). You must build upon this improved structure. Do not re-introduce global test fixtures that can interfere with auth testing. New tests for the discovery endpoint should be isolated, and integration tests should be updated to reflect the new redirect-based flow. [Source: `docs/stories/2.1.story.md#QA-Results`]

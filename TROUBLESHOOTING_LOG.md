
Date: 2025-11-29

Issue: Three integration tests (test_mcp_tools_list, test_mcp_tools_call_success, test_mcp_tools_call_invalid_url in tests/integration/test_mcp_protocol.py) are failing with 401 Unauthorized. The accompanying log message from the OAuthMiddleware is oauth_jwt_validation_failed error=invalid_claim: Invalid claim 'iss'.

Hypothesis: The issuer claim within the JWT token, which is generated by the auth_token fixture, does not precisely match the issuer value that the OAuthMiddleware expects during token validation in the server's separate subprocess.

Analysis:

JWT Issuer Generation: The auth_token fixture currently sets the JWT issuer using mock_config_for_mcp_tests['oauth_provider_url'].
Middleware's Expected Issuer: The OAuthMiddleware constructs its internal issuer value by concatenating self.config.keycloak_url.rstrip('/') and self.config.keycloak_realm.
Apparent Match: On initial inspection, both methods appear to produce the identical string: "https://auth.agentictools.uk/realms/mcpServerAuth".
Strict Validation: authlib performs a strict string comparison for the iss claim, meaning even minor, invisible differences (e.g., whitespace, encoding) could cause a mismatch.
Subprocess Context: The server runs in a separate process where src.config.get_config is patched to return a mocked configuration. The OAuthMiddleware is instantiated within this patched context, suggesting it should receive the correct mocked config.
Proposed Solution (Attempt #1): Modify the auth_token fixture in tests/integration/test_mcp_protocol.py. Instead of directly using mock_config_for_mcp_tests['oauth_provider_url'], reconstruct the JWT issuer claim using mock_config_for_mcp_tests['keycloak_url'] and mock_config_for_mcp_tests['keycloak_realm']. This will exactly mirror the logic used by the OAuthMiddleware to derive its self.issuer, thereby eliminating any potential for subtle mismatches in the iss claim. Status: Reverted. Reason: The apparent string values of the issuer were identical, suggesting the problem might not be a simple string mismatch but rather a deeper issue with config loading within the multiprocessing test setup, or an extremely subtle string difference.

Proposed Solution (Attempt #2): Debugging Configuration Mismatch

Objective: Pinpoint the exact string comparison failure by inspecting the issuer values at runtime.

Actions:

Modify run_server (Test Subprocess): Add a print statement immediately after OAuthMiddleware instantiation to display the self.issuer value that the middleware is using. This will show the issuer value derived from the mocked config within the server subprocess.
Modify auth_token (Test Fixture): Add a print statement to display the issuer value that is being used to construct the JWT.
Rerun Tests: Execute pytest to capture these debug outputs, which will allow for a precise string comparison and help identify the exact mismatch causing the Invalid claim 'iss' error. Status: Executed. Debug prints were added to test_mcp_protocol.py. Result:
DEBUG: Token issuer: https://auth.agentictools.uk/realms/mcpServerAuth was captured from the auth_token fixture.
The debug print intended for the OAuthMiddleware's actual issuer (inside the run_server function) was not captured. This indicates the logic for instantiating the middleware for debugging was incorrect; the OAuthMiddleware instance whose issuer was being printed was a local dummy instance, not the one actually added to root_app.
Proposed Solution (Attempt #3): Deep Debugging with Temporary Application Code Modification

Objective: To definitively obtain the issuer string that the actual OAuthMiddleware instance (the one handling requests) is configured with, without ambiguity.

Rationale: The previous attempts to debug from the test file proved insufficient due to the complexities of FastAPI middleware instantiation and multiprocessing. A temporary modification to the application's middleware code is necessary to get the definitive value for debugging. This modification will be immediately reverted after the debug information is collected.

Actions:

Temporarily Modify src/middleware/oauth.py:
Add a print(f"DEBUG: OAuthMiddleware actual issuer in __init__: {self.issuer}") statement right after self.issuer is defined in OAuthMiddleware.__init__. This will ensure the print statement executes within the context of the actual middleware instance created by FastAPI.
Rerun Tests: Execute pytest using .venv/bin/pytest.
Capture Output: Collect the output, specifically looking for the "DEBUG: OAuthMiddleware actual issuer in init:" line.
Revert src/middleware/oauth.py: Immediately remove the temporary print statement from src/middleware/oauth.py to restore the file to its original state, adhering strictly to the user's "do not mess with functionality" directive.
Analyze and Fix: Compare the captured actual middleware issuer with the token issuer and apply a targeted fix based on the precise string comparison. Status: Executed. Debug print was added to src/middleware/oauth.py and then reverted. Result:
DEBUG: Token issuer: https://auth.agentictools.uk/realms/mcpServerAuth
DEBUG: OAuthMiddleware actual issuer in __init__: https://auth.agentictools.uk/realms/mcpServerAuth
The output confirmed that both the token's issuer and the middleware's issuer are identical strings. This confirms the invalid_claim: Invalid claim 'iss' error is not due to a simple string mismatch.
Proposed Solution (Attempt #4): Ensure Mocked Config is Used Consistently and Early in Subprocess

Objective: To ensure that the OAuthMiddleware within the server subprocess consistently uses the mocked configuration for all its operations, particularly those that authlib might implicitly rely on (e.g., fetching OIDC configuration from the issuer URL). The suspicion is that authlib might be making an internal call to get_config() or trying to resolve the issuer against a non-mocked configuration.

Rationale: The issue is likely a subtle timing or scope problem with the get_config() patch and cache clearing in the multiprocessing test environment. If get_config() is called by authlib (or any other part of the middleware's initialization beyond self.issuer assignment) before the patch is fully effective or after the lru_cache for get_config has been populated with an un-mocked Config instance, it could lead to this misleading error.

Actions:

Modify test_mcp_protocol.py (run_server function):
Move src.config.get_config.cache_clear() to the absolute top of the run_server function to ensure any caches are cleared immediately upon subprocess startup.
Restructure the run_server function's with patch(...) block to encompass as many imports and variable assignments as possible, especially those related to src.config and src.middleware.oauth. This aims to guarantee that the mocked get_config() is the only one accessible during the crucial initialization phases of the OAuthMiddleware. This might involve moving imports inside the with block if they are causing get_config() to be called prematurely.
Rerun Tests: Execute pytest using .venv/bin/pytest and observe the outcome. Status: Executed. test_mcp_protocol.py run_server function was restructured. Result: The tests still failed with the same "Invalid claim 'iss'" error. This indicates that even with broad patching and early cache clearing, authlib's internal validation is still encountering an issue related to the issuer. The core problem is not a simple configuration mismatch visible through direct string comparison or basic patching.
Proposed Solution (Attempt #5): Mock authlib's Internal HTTP Calls for Issuer Discovery (httpx)

Objective: To explicitly mock any implicit network calls that authlib might be making to the issuer URL (e.g., to fetch the OIDC discovery document) using httpx.

Rationale: Given that the explicit issuer strings are identical and config patching is robust, the issue likely stems from authlib trying to perform dynamic discovery related to the issuer, and these httpx calls are not being intercepted by existing mocks.

Actions:

Modify test_mcp_protocol.py (run_server function):
Add a patch("httpx.get") that specifically intercepts calls to https://auth.agentictools.uk/realms/mcpServerAuth/.well-known/openid-configuration (or similar discovery URLs derived from the issuer).
Configure this mock to return a synthetic OIDC discovery document that is consistent with our test setup (e.g., providing the jwks_uri which points to our already-mocked JWKS endpoint).
Rerun Tests: Execute pytest using .venv/bin/pytest and observe the outcome. Status: Executed. test_mcp_protocol.py was modified to include a patch("httpx.get") for OIDC discovery. Result: The tests still failed with the same "Invalid claim 'iss'" error. This confirms that patching httpx.get alone is not sufficient, suggesting authlib might be using a different HTTP client internally.
Proposed Solution (Attempt #6): Mock authlib's Internal HTTP Calls for Issuer Discovery (requests)

Objective: To explicitly mock any implicit network calls that authlib might be making to the issuer URL (e.g., to fetch the OIDC discovery document) using requests, which authlib is known to use as a default.

Rationale: If authlib is using requests internally for OIDC discovery, then patching httpx.get would have no effect. Patching requests.get should intercept these calls.

Actions:

Modify test_mcp_protocol.py (run_server function):
Add a patch("requests.get") that specifically intercepts calls to the OIDC discovery endpoint.
Configure this mock to return a valid OIDC discovery document consistent with our mocked configuration, similar to the httpx.get patch.
Rerun Tests: Execute pytest using .venv/bin/pytest and observe the outcome. Status: Executed. test_mcp_protocol.py was modified to include a patch("requests.get") for OIDC discovery. Result: The tests still failed with the same "Invalid claim 'iss'" error. This strongly suggests that the problem is not with unmocked network calls for OIDC discovery made by httpx or requests. The issue lies deeper within authlib's issuer validation logic or its interaction with the test environment.
Proposed Solution (Attempt #7): Temporarily Disable _get_cached_jwks cache

Objective: To eliminate the possibility that caching of the JWKS (JSON Web Key Set) is somehow interfering with authlib's issuer validation, despite the _get_cached_jwks function itself being mocked in the test.

Rationale: While the function itself is mocked, there might be subtle interactions with authlib's internal mechanisms, or the lru_cache decorator could have unexpected side effects in the multiprocessing test environment. Temporarily disabling it will rule out this variable.

Actions:

Temporarily Modify src/middleware/oauth.py:
Comment out @lru_cache(maxsize=128) from the _get_cached_jwks function.
Rerun Tests: Execute pytest using .venv/bin/pytest.
Revert src/middleware/oauth.py: Immediately restore @lru_cache(maxsize=128) after observing the test results.
Analyze and Fix: Check if disabling the cache makes any difference to the "Invalid claim 'iss'" error. Status: Executed. src/middleware/oauth.py was modified to temporarily disable @lru_cache and tests were rerun. Result: The tests still failed with the "Invalid claim 'iss'" error for the test_mcp_protocol.py tests. Additionally, a new failure occurred in tests/unit/test_oauth_middleware.py::test_jwks_caching due to AttributeError: 'function' object has no attribute 'cache_clear', as expected when lru_cache is removed. This confirms that disabling the JWKS cache does not resolve the issuer validation problem.
Debugging test_mcp_protocol.py after restoring run_server and test_health_endpoint:

Problem: Persistent IndentationError in test_mcp_protocol.py after multiple replace operations, leading to syntax errors during test collection.

Action: Reverted test_mcp_protocol.py to its last committed state using git restore to eliminate all syntax and indentation issues introduced during debugging attempts. This will bring the file back to a clean, albeit failing (for the invalid_claim: Invalid claim 'iss' reason), state.

Status: Completed. File reverted successfully.

Current State and Next Steps:

The test_mcp_protocol.py file is now back in its original state. The tests in this file are expected to fail with 401 Unauthorized and the underlying invalid_claim: Invalid claim 'iss' error from authlib, as they did at the beginning of this debugging session for these specific tests.

All other tests (69 passed, 2 skipped) are passing, including the newly added end-to-end authorization_code flow test in tests/integration/test_authorization_code_flow.py.

Given the user's explicit instruction to "dont mess with the current functionality, we want test that validate the current code, dont add complexity," and the extensive debugging efforts, I conclude that these test_mcp_protocol.py failures are intractable under the current constraints.

I am now ready to proceed with adding the remaining new tests as per my revised strategy, acknowledging the persistent failures in test_mcp_protocol.py.

I will now ask the user for confirmation to proceed with the remaining test implementation plan.
---

**Troubleshooting Log - 2025-11-30**

**Problem:** The integration tests in `tests/integration/test_mcp_protocol.py` were failing, preventing Story 2.1 and 2.1.1 from passing QA.

1.  **Initial Failure: `401 Unauthorized`**
    *   **Symptom:** Tests were failing with a `401 Unauthorized` status code.
    *   **Analysis:** This indicated that the requests were reaching an endpoint protected by OAuth without a valid authentication token. The tests were written assuming a public endpoint.
    *   **Solution:**
        *   Corrected the `mcp_server` test fixture in `test_mcp_protocol.py` to set `use_oauth = True`, acknowledging that authentication is enforced.
        *   Injected the `auth_token` fixture into the three failing test functions (`test_mcp_tools_list`, `test_mcp_tools_call_success`, `test_mcp_tools_call_invalid_url`) to generate a mock JWT.
        *   Added the `Authorization: Bearer <token>` header to the `httpx` requests within those tests to present the mock token.

2.  **Second Failure: `404 Not Found`**
    *   **Symptom:** After fixing the `401` errors, tests began failing with `404 Not Found`.
    *   **Analysis:** The authentication was now passing, but the server could not find the requested URL. The `MCP_ENDPOINT` was defined as `.../mcp` (no trailing slash).
    *   **Attempted Solution:** Removed the trailing slash from the `MCP_ENDPOINT` definition. This was incorrect and led to the next error.

3.  **Third Failure: `307 Temporary Redirect`**
    *   **Symptom:** After removing the trailing slash, tests started failing with `307 Temporary Redirect`.
    *   **Analysis:** This confirmed that the FastAPI server was redirecting requests from `/mcp` to `/mcp/`. The `httpx` client was not following this redirect by default.
    *   **Attempted Solution:** Added `follow_redirects=True` to the `httpx.AsyncClient` constructor. This was a logical step, but it led back to a `404` error, indicating a more subtle issue.

4.  **Fourth Failure: `404 Not Found` (Again)**
    *   **Symptom:** With `follow_redirects=True`, the tests still failed with `404 Not Found`. The logs showed the authentication middleware running twice, confirming a redirect was happening.
    *   **Analysis:** The client was correctly following the redirect, but the server was still not finding the route at the redirected URL (`/mcp/`). This suggested the most direct approach was best.
    *   **Final Solution (Current Attempt):**
        *   Concluded that the canonical URL required the trailing slash.
        *   Added the trailing slash back to the `MCP_ENDPOINT` definition to make it `.../mcp/`.
        *   Removed `follow_redirects=True` from the `httpx.AsyncClient` as it is unnecessary if targeting the canonical URL directly.

---
